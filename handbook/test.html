<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>执行上下文和执行栈 | HONGSIR12</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="HONGSIR12的个人博客">
    
    <link rel="preload" href="/hongsir_blog/assets/css/0.styles.2eb091cc.css" as="style"><link rel="preload" href="/hongsir_blog/assets/js/app.9297bffd.js" as="script"><link rel="preload" href="/hongsir_blog/assets/js/3.ebdb556f.js" as="script"><link rel="preload" href="/hongsir_blog/assets/js/1.52e1aeda.js" as="script"><link rel="preload" href="/hongsir_blog/assets/js/11.c738428c.js" as="script"><link rel="prefetch" href="/hongsir_blog/assets/js/10.4e8caf41.js"><link rel="prefetch" href="/hongsir_blog/assets/js/12.08559c69.js"><link rel="prefetch" href="/hongsir_blog/assets/js/4.d4318ce5.js"><link rel="prefetch" href="/hongsir_blog/assets/js/5.2d496154.js"><link rel="prefetch" href="/hongsir_blog/assets/js/6.6388cacd.js"><link rel="prefetch" href="/hongsir_blog/assets/js/7.15b4c143.js"><link rel="prefetch" href="/hongsir_blog/assets/js/8.15bec023.js"><link rel="prefetch" href="/hongsir_blog/assets/js/9.8f60ca7b.js">
    <link rel="stylesheet" href="/hongsir_blog/assets/css/0.styles.2eb091cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>HONGSIR12</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>HONGSIR12的个人博客</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hongsir_blog/" class="home-link router-link-active"><!----> <span class="site-name">HONGSIR12</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/hongsir_blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      HONGSIR的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hongsir12" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_43990650?type=blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>2</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/hongsir_blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      HONGSIR的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/hongsir12" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_43990650?type=blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/hongsir_blog/" class="sidebar-heading clickable router-link-active open"><span>欢迎光临</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/hongsir_blog/" aria-current="page" class="sidebar-link">hongsir</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/hongsir_blog/handbook/test" class="sidebar-heading clickable active"><span>面试</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/hongsir_blog/handbook/test1.html" class="sidebar-link">测试1</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">执行上下文和执行栈</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="执行上下文和执行栈"><a href="#执行上下文和执行栈" class="header-anchor">#</a> 执行上下文和执行栈</h1> <h2 id="执行上下文类型"><a href="#执行上下文类型" class="header-anchor">#</a> 执行上下文类型</h2> <hr> <p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。</p> <p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 window 对象，<code>this</code> 指向这个全局对象。</p> <p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p> <p><strong><code>Eval</code> 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用</p> <h2 id="执行栈"><a href="#执行栈" class="header-anchor">#</a> 执行栈</h2> <p>用于存储在代码执行期间创建的所有执行上下文。</p> <h4 id="执行上下文的创建"><a href="#执行上下文的创建" class="header-anchor">#</a> 执行上下文的创建</h4> <p>执行上下文分两个阶段创建：<strong>1）创建阶段；</strong> <strong>2）执行阶段</strong></p> <h4 id="创建阶段"><a href="#创建阶段" class="header-anchor">#</a> 创建阶段</h4> <ul><li>1、确定 <strong>this</strong> 的值，也被称为 <strong>This Binding</strong>。</li> <li>2、<strong><code>LexicalEnvironment（词法环境）</code></strong> 组件被创建。</li> <li>3、<strong><code>VariableEnvironment（变量环境）</code></strong> 组件被创建。</li></ul> <p><strong>变量提升</strong>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 <code>undefined</code>（在 <code>var</code> 的情况下）或保持未初始化（在 <code>let</code> 和 <code>const</code> 的情况下）。所以这就是为什么可以在声明之前访问 <code>var</code> 定义的变量（尽管是 <code>undefined</code> ），但如果在声明之前访问 <code>let</code> 和 <code>const</code> 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p> <h4 id="执行阶段"><a href="#执行阶段" class="header-anchor">#</a> 执行阶段</h4> <p>此阶段，完成对所有变量的分配，最后执行代码。</p> <h2 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="header-anchor">#</a> 变量提升和函数提升</h2> <p>例子一：<strong>变量提升</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>foo<span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo1，foo赋值</span>

<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo2，foo重新赋值</span>
</code></pre></div><p>例子二：<strong>函数提升</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo2</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo2</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo2</span>
</code></pre></div><p>例子三：声明优先级，<strong>函数 &gt; 变量</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo2</span>
<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// foo1，foo重新赋值</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo1</span>
</code></pre></div><p>上面三个例子中，第一个例子是变量提升，第二个例子是函数提升，第三个例子是函数声明优先级高于变量声明。</p> <p><strong>需要注意</strong>的是同一作用域下存在多个同名函数声明，后面的会替换前面的函数声明。</p> <h1 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h1> <p>在JS中只有函数对象才有<code>prototype</code>属性。</p> <p>当我们创建函数时，JS会为这个函数自动添加<code>prototype</code>属性，它的值是一个有<code>constructor</code>属性的对象，而不是空对象。一旦把这个函数当作构造函数去调用(即通过<code>new</code>关键字调用)，那么JS会帮我们创建该构造函数的实例，实例继承构造函数<code>prototype</code>的所有属性和方法。</p> <p>实例对象的<code>__proto__</code>指向自己构造函数的<code>prototype</code></p> <h1 id="css盒子水平垂直居中"><a href="#css盒子水平垂直居中" class="header-anchor">#</a> CSS盒子水平垂直居中</h1> <p>五种</p> <h1 id="清除浮动"><a href="#清除浮动" class="header-anchor">#</a> 清除浮动</h1> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.clearfix:after</span><span class="token punctuation">{</span>
    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>
    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">,</span>
    <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="经典布局"><a href="#经典布局" class="header-anchor">#</a> 经典布局</h1> <h2 id="圣杯布局-左右固定中间自适应"><a href="#圣杯布局-左右固定中间自适应" class="header-anchor">#</a> 圣杯布局：左右固定中间自适应</h2> <p>浮动和负margin</p> <p>flex</p> <p>定位</p> <h1 id="移动端响应式布局开发三大方案"><a href="#移动端响应式布局开发三大方案" class="header-anchor">#</a> 移动端响应式布局开发三大方案</h1> <p>media媒体查询</p> <p>rem</p> <p>flex</p> <p><code>vh</code>/<code>vw</code></p> <h1 id="堆栈"><a href="#堆栈" class="header-anchor">#</a> 堆栈</h1> <p>堆：存储引用类型值的空间</p> <p>栈：存储基本类型值和执行代码的环境</p> <h1 id="tostring-和valueof"><a href="#tostring-和valueof" class="header-anchor">#</a> <code>toString()</code>和<code>valueOf()</code></h1> <p><code>toString( )</code>就是将其他东西用字符串表示，比较特殊的地方就是，表示对象的时候，变成&quot;[object Object]&quot;,表示数组的时候，就变成数组内容以逗号连接的字符串，相当于<code>Array.join(',')</code>。 而<code>valueOf( )</code>就返回它自身了。</p> <h1 id="对象-数组-的深浅克隆"><a href="#对象-数组-的深浅克隆" class="header-anchor">#</a> 对象(数组)的深浅克隆</h1> <p><code>JSON.parse(JSON.stringify(obj))</code>：弊端：函数、正则、undefined会被忽略不计</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 过滤特殊情况</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token operator">!==</span><span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 不直接创建空对象目的：克隆的结果和之前保持相同的所属类</span>
    <span class="token keyword">let</span> newObj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="内存回收"><a href="#内存回收" class="header-anchor">#</a> 内存回收</h1> <p>js垃圾自动收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出不再继续使用的值，然后释放其占用的内存。</p> <h2 id="局部变量和全局变量的销毁"><a href="#局部变量和全局变量的销毁" class="header-anchor">#</a> 局部变量和全局变量的销毁</h2> <h3 id="局部变量"><a href="#局部变量" class="header-anchor">#</a> 局部变量</h3> <p>局部作用域中，当函数执行完毕，局部变量就没有存在的必要，因此垃圾收集器很容易判断并回收</p> <h3 id="全局变量"><a href="#全局变量" class="header-anchor">#</a> 全局变量</h3> <p>全局变量什么时候需要自动释放内存空间则很难判断，所以开发中尽量避免使用全局变量</p> <h1 id="内存泄漏"><a href="#内存泄漏" class="header-anchor">#</a> 内存泄漏</h1> <p>对于持续运行的服务进程，必须及时释放不再用到的内存。对于不再用到的内存，没有及时释放就叫做内存泄漏。</p> <h1 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h1> <p>简单定义：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被称作闭包。</p> <p>定义：闭包是有权访问另外一个函数作用域中的变量的函数。</p> <h1 id="同步异步"><a href="#同步异步" class="header-anchor">#</a> 同步异步</h1> <p>浏览器是多线程的，JS是单线程--&gt;浏览器只给了其一个线程来渲染。</p> <p>宏任务：定时器、事件绑定、ajax</p> <p>微任务：promise、async await、process.nextTick</p> <h1 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="header-anchor">#</a> 箭头函数与普通函数区别</h1> <p>箭头函数不能被new，无法new一个箭头函数(没有原型链prototype)。</p> <p>箭头函数没有自己的this，它的this都继承自其上下文的this。</p> <h1 id="俩个等号-的比较规则"><a href="#俩个等号-的比较规则" class="header-anchor">#</a> 俩个等号==的比较规则</h1> <p>对象==字符串，对象.toString()变为字符串</p> <p>null==undefined相等，但是和其他值比较就不相等</p> <p>NaN==NaN不相等</p> <p>剩下的都是转换为数字</p> <h1 id="防抖"><a href="#防抖" class="header-anchor">#</a> 防抖</h1> <p>触发事件后n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay<span class="token operator">=</span><span class="token number">200</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> args <span class="token operator">=</span> arguments
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="节流"><a href="#节流" class="header-anchor">#</a> 节流</h1> <p>连续触发事件但是在n秒内只执行一次函数，也就是稀释函数的执行频率</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay<span class="token operator">=</span><span class="token number">200</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>
        flag <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token keyword">const</span> args <span class="token operator">=</span> arguments
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="手写ajax"><a href="#手写ajax" class="header-anchor">#</a> 手写ajax</h1> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ajax <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">fn</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">post</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span>data<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span>url<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Contnet-type'</span><span class="token punctuation">,</span><span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">fn</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="mvc和mvvm的区别"><a href="#mvc和mvvm的区别" class="header-anchor">#</a> MVC和MVVM的区别</h1> <h2 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h2> <p>model模型：负责从数据库中获取数据</p> <p>view视图：负责展示数据的地方</p> <p>controller控制器：用户交互的地方如点击事件</p> <p>思想：controller将model的数据展示在view上</p> <h2 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h2> <p>view-model：做了两件事达到数据的双向绑定。</p> <p>1.将model模型转化为view视图，即通过数据绑定将后端传递的数据转化成所看到的页面。</p> <p>2.将view视图转化为model模型，即通过dom事件监听将看到的页面转化为后端的数据。</p> <p>思想：实现了view和model的自动同步，当model的属性改变时，我们不用再自己手动操作dom元素来改变view的显示，而是改变属性后该属性对应view层会自动改变。</p> <h1 id="vue"><a href="#vue" class="header-anchor">#</a> <code>Vue</code></h1> <h2 id="双向数据绑定的实现原理"><a href="#双向数据绑定的实现原理" class="header-anchor">#</a> 双向数据绑定的实现原理</h2> <p>2.0： ES5 <code>Object.defineProperty</code>数据劫持+观察者模式</p> <p>缺点：</p> <p>1.对原始数据克隆</p> <p>2.需要分别给对象中的每一个属性设置监听</p> <h2 id="常用指令"><a href="#常用指令" class="header-anchor">#</a> 常用指令</h2> <p><code>v-show</code>：根据表达式真假值，切换元素的display CSS property。</p> <p><code>v-if</code>：根据表达式的值有条件的渲染元素。切换元素时元素的数据绑定/组件被销毁并重建。</p> <p><code>v-html</code>：更新元素的innerHTML</p> <p><code>v-text</code>：更新元素的textContent</p> <p><code>v-for</code>：列表循环渲染，数组、对象、数字、字符串都可以</p> <p><code>v-on</code>：绑定事件</p> <p><code>v-bind</code>：动态绑定各种变量</p> <p><code>v-model</code>：双向绑定表单项的值</p> <p><code>v-once</code>：元素和组件只渲染一次</p> <p><code>v-slot</code>：插槽名</p> <h2 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h2> <p><code>.trim</code>:把v-model绑定的值的首位空格给过滤掉</p> <p><code>.stop</code>:阻止冒泡</p> <p><code>.self</code>：只有点击事件绑定的本身才会触发事件</p> <p><code>.number</code>：将值转成数字，但是先输入数字只取前面数字部分，先输入字母的话该修饰符无效</p> <p><code>.lazy</code>：改变输入框的值时value不会改变，当光标离开输入框时，v-model绑定的value才会改变</p> <p><code>.once</code>：事件只执行一次</p> <p><code>.capture</code>:事件默认由里往外冒泡，capture修饰符的作用是反过来的由外往里捕获</p> <p><code>.prevent</code>：阻止默认事件(如a标签的跳转)</p> <p><code>.native</code>：加载自定义组件的事情上保证事件能执行</p> <p>.camel：确保绑定参数被识别为驼峰写法</p> <p><code>.sync</code>：父子组件传值，子组件想更新这个值，使用该修饰符可简写</p> <h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> <code>nextTick</code></h2> <p>vue采取的是异步更新Dom策略，所以数据一更新，视图却还没更新，拿到的还是上一次的旧视图数据。</p> <p>nextTick里面的代码会在dom更新后执行</p> <h2 id="动态class和style"><a href="#动态class和style" class="header-anchor">#</a> 动态class和style</h2> <p>动态class对象：<code>&lt;div :class=&quot;{ 'is-active': true, 'red': isRed }&quot;&gt;&lt;/div&gt;</code></p> <p>动态class数组：<code>&lt;div :class=&quot;['is-active', isRed ? 'red' : '' ]&quot;&gt;&lt;/div&gt;</code></p> <p>动态style对象：<code>&lt;div :style=&quot;{ color: textColor, fontSize: '18px' }&quot;&gt;&lt;/div&gt;</code></p> <p>动态style数组：<code>&lt;div :style=&quot;[{ color: textColor, fontSize: '18px' }, { fontWeight: '300' }]&quot;&gt;&lt;/div&gt;</code></p> <h2 id="computed和watch区别"><a href="#computed和watch区别" class="header-anchor">#</a> computed和watch区别</h2> <p>1.computed是依赖已有的变量来计算一个目标变量，大多数情况都是<strong>多个变量</strong>凑在一起计算出<strong>一个变量</strong>，并且computed具有缓存机制，依赖值不变的情况下其会直接读取缓存进行复用，computed不能进行异步操作</p> <p>2.watch是监听某一个变量的变化，并执行相应的回调函数，通常是<strong>一个变量</strong>的变化决定<strong>多个变量</strong>，watch可以进行异步操作</p> <p>简单来说就是一般情况下computed是多对一，watch是一对多</p> <h1 id="跨域问题的解决方案和实现原理"><a href="#跨域问题的解决方案和实现原理" class="header-anchor">#</a> 跨域问题的解决方案和实现原理</h1> <h1 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h1> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment">//Array.from(new Set(arr))</span>
<span class="token comment">// Set和Map类似，也是一组key的集合，但是不存储value，由于key不能重复，所以Set里没有重复的key</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>


</code></pre></div><p>会改变数组的方法：push、pop、shift、unshift、splice、reverse、sort</p> <p>不会改变数组的方法：filter、map、slice、concat</p> <h1 id="回流reflow和重绘repaint"><a href="#回流reflow和重绘repaint" class="header-anchor">#</a> 回流reflow和重绘repaint</h1> <p>回流必将引起重绘，重绘不一定引起回流。回流比重绘的代价要更高。</p> <p><strong>回流</strong></p> <ol><li><p>当render tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程成为回流。</p></li> <li><p>导致回流的操作：</p> <p>页面首次渲染、浏览器窗口大小发生改变、元素尺寸或位置发生改变、元素内容变化、元素字体大小变化、添加或删除可见的<code>dom</code>元素、激活<code>css</code>伪类、查询某些属性或调用某些方法</p></li> <li><p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li> <li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li> <li><code>scrolWidth</code>、、、</li> <li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul></li></ol> <p><strong>重绘</strong></p> <ol><li>当页面中元素样式的改变并不影响它在文档流中的位置时(如<code>color</code>、<code>background-color</code>、<code>visibility</code>)，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</li></ol> <h1 id="html"><a href="#html" class="header-anchor">#</a> HTML</h1> <p><code>clientWidth</code> = 宽度 + padding</p> <p><code>offsetWidth</code> = 宽度 + padding + border</p> <p>web表单登录图形验证实现：服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务器端保存文本的验证码,由服务器端验证输入内容是否正确，客户端出于安全考虑不能直接在客户端进行验证</p> <p>web程序对象作用域：请求作用域、会话作用域、应用上下文</p> <p><code>main</code> 标签规定文档的主要内容； <code>dir</code> 定义目录列表； <code>dd</code> 为定义列表中项目的描述； <code>pre</code> 可定义预格式化的文本。</p> <p><code>input</code>元素的类型：<code>button</code>、<code>checkbox</code>、<code>file</code>、<code>hidden</code>、<code>image</code>、<code>password</code>、<code>radio</code>、<code>reset</code>、<code>submit</code>、<code>text</code></p> <p><code>video</code>标签定义视频、<code>source</code>标签定义媒体资源、<code>track</code>标签为音视频规定外部文本轨道，不存在slider标签但是有个类似的<code>aside</code>标签</p> <p>html5的跨文档消息传输：可以实现同域内的web页面间的相互通信，可以相互传递字符串和对象，使用该功能需要获取到网页所在窗口对象的实例，跨文档已经是跨域的一种</p> <p><code>hr</code>分割线，<code>br</code>换行符</p> <p>带有id属性的<code>dom</code>元素的副作用：1.增加内存负担，2.会创建同名的全局变量</p> <p><code>inline</code>元素只能嵌套<code>inline</code>元素。</p> <p>一个页面不可以存在多个<code>title</code>元素。<code>main</code>元素只允许存在一个。</p> <p><code>h5</code>不再支持<code>center</code>、<code>font</code>、<code>strike</code>、<code>basefont</code>、<code>big</code>、<code>frame</code>、<code>arconym</code>这些元素</p> <p><code>h5</code>中<code>getCurrentPosition()</code>用于获取用户当前位置</p> <p><code>Domtree</code>的根节点是document</p> <p>a元素可以包含任何其他元素(除了自身)</p> <p><code>p</code>元素不能包含任何块级元素（包括自身）</p> <p><code>a</code>标签没有设置<code>href</code>属性时是不能获取到焦点的</p> <p><code>label</code>标签只有俩个属性<code>for</code>和<code>form</code>：<code>for</code>规定<code>label</code>绑定到哪个表单元素，<code>form</code>规定<code>label</code>字段所属的一个或多个表单</p> <p><code>&lt;!DOCTYPE&gt;</code>标签没有结束标签，声明不区分大小写。</p> <p><code>&lt;!DOCTYPE&gt;</code>声明不是一个HTML标签，它是用来告知web浏览器页面使用了哪种html版本</p> <p><code>DOM</code>树中有如下节点格式：<code>Element类型</code>元素节点，<code>Text类型</code>文本节点，<code>Comment类型</code>注释节点，<code>Document类型</code>document节点</p> <p>表格标记常用属性：</p> <p>1.<code>cellpadding</code>：单元格边沿与其内容之间的空白</p> <p>2.<code>cellspacing</code>：单元格之间的间距空白</p> <p>3.<code>border</code>：表格边框的宽度（边框粗细度）</p> <p>4.<code>align</code>：表格中文字内容对齐方式</p> <p>5.<code>frame</code>：外侧边框哪些部分可见</p> <p>6.<code>rules</code>：内侧边框哪些部分可见</p> <p><code>&lt;i&gt;和&lt;em&gt;</code>都表示斜体。前者单纯表示斜体，后踢表示强调</p> <h2 id="h5常用新特性"><a href="#h5常用新特性" class="header-anchor">#</a> <code>h5</code>常用新特性：</h2> <ul><li><p><code>canvas</code>元素：用于定义图形，只是图形容器，必须使用脚本来绘制图形</p></li> <li><p><code>audio</code>：用于音频播放</p></li> <li><p><code>video</code>：用于视频播放</p></li> <li><p><code>article</code>：规定独立的自包含内容</p></li> <li><p><code>header</code>：定义文档的页眉，介绍相关信息</p></li> <li><p><code>section</code>：定义文档中的节</p></li> <li><p><code>footer</code>：定义文档的页脚</p></li> <li><p><code>nav</code>：定义导航链接</p></li></ul> <p><code>SVG</code>：可伸缩矢量图形；用来定义用于网络的基于矢量的图形；使用<code>XML</code>格式定义图形；图像在放大或改变尺寸的情况下其图形质量不会有所损失；是万维网联盟的标准；是HTML下的一个分支；与诸如DOM和XSL之类的W3C标准是一个整体</p> <p><code>form</code>表单中<code>input</code>元素的<code>readonly</code>和<code>disabled</code>属性：<code>disabled</code>指当<code>input</code>元素加载时禁用此元素，<code>input</code>内容不会随着表单提交。<code>readonly</code>规定输入字段为只读，内容会随着表单提交。无论是<code>readonly</code>还是<code>disabled</code>，都能通过js更改<code>input</code>的值</p> <p><code>head</code>标签可以包含：1.<code>title</code>定义不同文档标题，2.<code>base</code>定义所有链接的URL，3.<code>link</code>定义文档与外部资源之间的关系，4.<code>style</code>定义文档的样式文件引用地址，也可直接添加样式渲染，5.<code>meta</code>描述一些基本的元数据，6.<code>script</code>用于加载脚本文件</p> <h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="header-anchor">#</a> 浏览器渲染流程</h1> <ol><li>解析HTML并构建DOM树</li> <li>解析CSS，生成CSS规则树</li> <li>合并DOM树和CSS规则，构建render树</li> <li>布局render树，负责各元素尺寸、位置计算</li> <li>绘制render树，绘制页面像素信息</li></ol> <h1 id="slice、splice和split"><a href="#slice、splice和split" class="header-anchor">#</a> slice、splice和split</h1> <h2 id="slice-截取功能"><a href="#slice-截取功能" class="header-anchor">#</a> slice：截取功能</h2> <p>从数组中截取任意元素，返回结果为新数组，不会改变原数组</p> <p>新数组 = 原数组.slice(开始位置的索引，结束位置的索引)</p> <p>注意：包含开始索引，不包含结束索引=&gt;[a,b)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> a1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无参数时，截取所有的元素。</span>
<span class="token keyword">let</span> a2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['c','d','e','f']</span>
<span class="token keyword">let</span> a3 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提取最后两个元素 负数会将其与长度相加，-2+6=4 ['e','f']</span>
<span class="token keyword">let</span> a4 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 提取从第二个到第四个之间的元素（不包括第四个元素）['c','d']</span>
<span class="token keyword">let</span> a5 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// []</span>
</code></pre></div><h2 id="splice-数组增删查改"><a href="#splice-数组增删查改" class="header-anchor">#</a> splice：数组增删查改</h2> <p>从数组中<strong>删除</strong>任意个（可以是负的即增加）元素，返回结果为<strong>被删除元素组成的新数组</strong></p> <p>该方法会改变原数组，会将指定元素从原数组中删除</p> <p>新数组 = 原数组.splice(起始索引，需要删除的个数)</p> <p>新数组 = 原数组.splice(起始索引，需要删除的个数，新元素1，新元素2)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> a1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 删除后--&gt; a1:['b','c','d','e','f']  arr:['a']</span>
<span class="token keyword">let</span> a2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">// 删除后--&gt; a2:['e','f']  arr:['a','b','c','d']</span>
<span class="token keyword">let</span> a3 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">//从index为1的位置开始删除元素，一共删除3个元素--&gt;a3:['b','c','d']  arr:['a','e','f']</span>
<span class="token keyword">let</span> a4 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">)</span><span class="token comment">//纯增加情况 a4:[],arr:['a','g','h','b', 'c', 'd', 'e', 'f']</span>
<span class="token keyword">let</span> a5 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'js'</span><span class="token punctuation">,</span><span class="token string">'vue'</span><span class="token punctuation">)</span><span class="token comment">// a5:['b','c','d'] arr:['a','js','vue','e','f']</span>
</code></pre></div><h2 id="split-字符串-数组"><a href="#split-字符串-数组" class="header-anchor">#</a> split：字符串=&gt;数组</h2> <p>split()是字符串的方法，不是数组的方法</p> <p><code>新的数组 = str.split(分隔符)</code></p> <p>通过<strong>指定的分隔符</strong>将一个字符串拆分成一个数组，不会改变原字符串</p> <h1 id="object-assign"><a href="#object-assign" class="header-anchor">#</a> <code>Object.assign()</code></h1> <p><code>Object.assign()</code>方法用于将所有可枚举属性的值，从一个或多个源对象<code>source</code>复制到目标对象，然后它将返回目标对象<code>target</code>。<code>Object.assign()</code>是浅拷贝</p> <p>第一个参数是目标对象<code>target</code>，后面的参数都是源对象</p> <p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">}</span>

<span class="token keyword">const</span> returnedTarget <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span>

target <span class="token comment">// { a: 1, b: 4, c: 5 }</span>
returnedTarget <span class="token comment">// { a: 1, b: 4, c: 5 }</span>
target<span class="token operator">===</span>returnedTarget <span class="token comment">//true</span>

</code></pre></div><p>如果参数不是对象，则会先转成对象再返回。<code>undefined</code>和<code>null</code>无法转成对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">//object</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">//报错 参数undefined也是报错</span>
</code></pre></div><p>如果非对象参数出现在源对象位置(非首参数)，这些参数都会转为对象，如果无法转为对象就会跳过。</p> <p>其他类型如(<code>number</code>、<code>string</code>、<code>boolean</code>)不在首参数也不会报错，但是除了字符串会以数组形式拷贝入目标对象，其他值都不会产生效果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> v1 <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token keyword">const</span> v2 <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">const</span> v3 <span class="token operator">=</span> <span class="token number">10</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">)</span>
obj <span class="token comment">// { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</span>

</code></pre></div><p>可以用来处理数组，但是会把数组视为对象</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// [4,5,3]</span>
</code></pre></div><h1 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h1> <h1 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h1> <p>什么是缓存？</p> <p>通俗一点，第一次访问网站时会把图片和数据下载到本地上，当再次访问该网站时就直接加载出来</p> <p>缓解服务器压力，减少请求次数</p> <p>提升性能，加载更快</p> <p>减少带宽消耗</p> <h2 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h2> <p>当访问URL时，不会向服务器发送请求，而是直接从缓存中读取资源，但是会返回200状态码</p> <h2 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h2> <p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程</p> <h1 id="vue双向数据绑定原理"><a href="#vue双向数据绑定原理" class="header-anchor">#</a> vue双向数据绑定原理</h1> <p>通过<strong>数据劫持结合发布者-订阅模式</strong>的方式实现。通过<code>ES5</code>提供的<code>Object.definePropperty()</code>方法来劫持各属性的<code>getter</code>、<code>setter</code>，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。</p> <h1 id="v-model语法糖怎么实现"><a href="#v-model语法糖怎么实现" class="header-anchor">#</a> v-model语法糖怎么实现</h1> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>就是v-bind数据绑定与v-on处理函数绑定的语法糖</p> <p>接受一个<code>value</code>属性，在有新的value时触发<code>input</code>事件</p> <h1 id="hash和history有什么区别"><a href="#hash和history有什么区别" class="header-anchor">#</a> hash和history有什么区别</h1> <h2 id="hash模式"><a href="#hash模式" class="header-anchor">#</a> hash模式</h2> <p>hash模式是一种把前端路由的路径用井号<code>#</code>拼接在真实<code>url</code>后面的模式。当井号后面的路径发生变化时，浏览器并不会重新发起请求，而是触发<code>onhashchange</code>事件</p> <p>特点：</p> <ul><li>hash变化会触发网页跳转，即浏览器的前进和后退</li> <li>hash可以改变URL，页面不会重新加载，即不会刷新页面。也就是说页面的跳转都是在客户端进行操作的，因此不算是一次http请求，所以该模式不利于SEO优化</li> <li>通过<code>window.onhashchange</code>方式监听hash的改变，借此实现无刷新跳转页面</li> <li>只需要前端配置路由表，不需要后端参与</li></ul> <h2 id="history模式"><a href="#history模式" class="header-anchor">#</a> history模式</h2> <p><code>historyAPI</code>是<code>H5</code>提供的新特性，允许开发者<strong>直接更改前端路由</strong>，即更新浏览器URL地址而<strong>不重新发起请求</strong>。</p> <p>特点：</p> <h2 id="二者选择"><a href="#二者选择" class="header-anchor">#</a> 二者选择</h2> <p><code>to B</code>的系统推荐hash，相对简单且容易使用，因为hash对url规范不敏感</p> <p><code>to C</code>的系统，考虑<code>H5 history</code>，但是需要服务端支持</p> <h1 id="set和map的区别"><a href="#set和map的区别" class="header-anchor">#</a> Set和Map的区别</h1> <p><code>Map</code>是一组键值对的结构，一个key只能对应一个value</p> <p><code>Set</code>是一组key的集合，但不存储value。由于key不能重复所以<code>Set</code>中没有重复的key。</p> <p>创建一个Set需要提供一个数组作为输入或直接创建一个空的Set，重复的元素在Set中自动被过滤</p> <h1 id="http协议特点"><a href="#http协议特点" class="header-anchor">#</a> http协议特点</h1> <p>HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：</p> <ol><li>支持客户/服务器模式</li> <li>简单快速:客户向服务器请求服务时，只需传送请求方法和路径</li> <li>灵活:HTTP允许传输任意类型的数据对象</li> <li><strong>无连接</strong>:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</li> <li><strong>无状态</strong>:HTTP协议无法根据之前的状态进行本次的请求处理</li></ol> <h1 id="localstorage和sessionstorage和cookie和session和token"><a href="#localstorage和sessionstorage和cookie和session和token" class="header-anchor">#</a> localstorage和sessionstorage和cookie和session和token</h1> <p>http协议是一种无状态协议，每次服务端收到客户端的请求时，都是一次全新的请求，服务器并不知道客户端的历史请求记录，session和cookie就是为了弥补http的无状态特性。</p> <h2 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h2> <p>浏览器发起http请求，服务器进行cookie设置<code>Set-Cookie</code>，cookie里面有名和值俩个属性，服务器会把其内容填充完整然后发给浏览器，浏览器将这个cookie保存起来。</p> <p>这样后浏览器以后发送的每一个请求都会自动附上这个cookie，说白了cookie就是一种存储在浏览器的数据而已。</p> <p>大小限制在4kb</p> <p>一般服务器生成，可设置失效时间，如果在浏览器端生成cookie默认关闭浏览器后失效</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399d7970b6~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <h2 id="session"><a href="#session" class="header-anchor">#</a> session</h2> <p>session是基于cookie实现的，客户端发起请求，服务端为此次请求开辟一块内存空间，也就是session对象，同时生成一个sessionID和会话结束时间，会被存储到客户端的cookie中，再把会话结束时间对应设置为这个cookie的有效期</p> <p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p> <p><a href="https://imgtu.com/i/bxBzk9" target="_blank" rel="noopener noreferrer"><img src="https://s1.ax1x.com/2022/03/15/bxBzk9.png" alt="bxBzk9.png"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="header-anchor">#</a> cookie和session的区别</h2> <ul><li>安全性：session比cookie安全，前者存储在服务端，后者存储在客户端</li> <li>存取值的类型不同：cookie只支持字符串数据，要设置成其他类型数据需要转为字符串，而session可以存任意类型数据</li> <li>有效期不同：cookie可设置为长时间保存，session一般客户端关闭就失效</li> <li>存储大小不同</li></ul> <h2 id="token"><a href="#token" class="header-anchor">#</a> token</h2> <p>访问资源接口API时需要的资源凭证</p> <ol><li>客户端使用用户名跟密码请求登录</li> <li>服务端收到请求，去验证用户名与密码</li> <li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li> <li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li> <li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li> <li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol> <p>每次请求都要携带token，把token放到http的header里</p> <p>基于token的用户认证是一种服务端的无状态认证方式，服务端不用存放token数据</p> <p>token完全由应用管理，所以可以避开同源策略</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <h2 id="token和session的区别"><a href="#token和session的区别" class="header-anchor">#</a> token和session的区别</h2> <p>session是<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。</p> <p>token是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>session是诞生并保存在服务器那边的</p> <p>cookie是一种数据载体，会把session放入cookie中送到客户端那边，cookie跟随http每个请求发送出去</p> <p>token是诞生在服务器但保存在浏览器这边，由客户端主导，可放在cookie或storage里面，持有token就像持有令牌一样可以允许访问服务器</p> <h2 id="localstorage和sessionstorage"><a href="#localstorage和sessionstorage" class="header-anchor">#</a> localStorage和sessionStorage</h2> <p>共同点：</p> <ol><li><p>存储大小均为5M左右</p></li> <li><p>都有同源策略限制</p></li> <li><p>仅保存在客户端，不参与服务器通信</p></li></ol> <p>不同点：</p> <ol><li><p>生命周期：</p> <ul><li><p>localstorage存储的数据是永久的，除非人为删除否则会一直存在</p></li> <li><p>sessionstorage与存储数据的脚本所在标签页的有效期是相同的，一旦窗口或标签页被关闭，存储的数据也会被删除</p></li></ul></li> <li><p>作用域：</p> <ul><li>localstorage：在同一个浏览器内，<strong>同源文档</strong>间共享localstorage数据，可相互读取覆盖</li> <li>sessionstorage：一样需要同浏览器同源文档条件，不仅如此，其作用域还被限定在窗口中，只有同一浏览器、同一窗口的同源文档才能共享数据。比如：浏览器中打开了俩个相同地址页面A和B，虽然页面源完全相同，但还是不能共享数据，因为不同窗口。</li></ul></li></ol> <h1 id="vuex有哪些基本属性"><a href="#vuex有哪些基本属性" class="header-anchor">#</a> vuex有哪些基本属性</h1> <ol><li>state =》基本数据</li> <li>getters =》从基本数据派生出的数据</li> <li>mutations =》修改数据，同步</li> <li>actions =》修改数据，异步(Action提交的是mutation而不是直接变更状态)</li> <li>modules =》模块化Vuex</li></ol> <h1 id="在地址栏输入一个地址回车会发生什么事情"><a href="#在地址栏输入一个地址回车会发生什么事情" class="header-anchor">#</a> 在地址栏输入一个地址回车会发生什么事情</h1> <ol><li>URL解析</li> <li>DNS查询</li> <li>TCP连接</li> <li>处理请求</li> <li>接收响应</li> <li>渲染页面</li></ol> <h1 id="udp和tcp的区别"><a href="#udp和tcp的区别" class="header-anchor">#</a> UDP和TCP的区别</h1> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/1706fe0aa460d91c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt=""></p> <h1 id="项目中常用的性能优化方式"><a href="#项目中常用的性能优化方式" class="header-anchor">#</a> 项目中常用的性能优化方式</h1> <ol><li>减少和http请求</li> <li>将css放文件头部，js文件放底部</li> <li>用字体图标代替图片图标</li> <li>善用缓存，不重复加载相同资源</li> <li>减少重绘重排</li></ol> <h1 id="计算属性和watch的区别"><a href="#计算属性和watch的区别" class="header-anchor">#</a> 计算属性和watch的区别</h1> <ol><li>computed计算属性：依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值</li> <li>watch监听器：无缓存性，类似于某些数据的监听回调，当监听的数据变化时便会执行回调进行后续操作</li></ol> <h1 id="vue生命周期和每个钩子具体做了什么"><a href="#vue生命周期和每个钩子具体做了什么" class="header-anchor">#</a> vue生命周期和每个钩子具体做了什么</h1> <h1 id="组件间传值的几种方式"><a href="#组件间传值的几种方式" class="header-anchor">#</a> 组件间传值的几种方式</h1> <ol><li>父传子：子组件通过props['xx']来接收父组件传递的属性xx的值</li> <li>子传父：子组件通过<code>this.$emit('fn',value)</code>来传递，父组件通过接收fn事件方法接收回调</li> <li>使用Vuex</li> <li>创建bus</li></ol> <h1 id="父子组件生命周期顺序"><a href="#父子组件生命周期顺序" class="header-anchor">#</a> 父子组件生命周期顺序</h1> <ol><li><p>加载渲染过程：</p> <p>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p></li> <li><p>子组件更新过程：</p> <p>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父update</p></li> <li><p>父组件更新过程：</p> <p>父beforeUpdate -&gt; 父update</p></li> <li><p>销毁过程：</p> <p>父beforeDestory -&gt; 子beforeDestory -&gt; 子destroyed -&gt; 父destroyed</p></li></ol> <h1 id="eventbus具体怎么实现"><a href="#eventbus具体怎么实现" class="header-anchor">#</a> <code>EventBus</code>具体怎么实现</h1> <h1 id="keepalive是什么-有哪些钩子"><a href="#keepalive是什么-有哪些钩子" class="header-anchor">#</a> <code>keepalive</code>是什么，有哪些钩子</h1> <p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以用keepalive组件包裹需要保存的组件</p> <p>两个重要属性，include 缓存组件名称，exclude 不需要缓存的组件名称。</p> <h1 id="插槽是什么-怎么使用"><a href="#插槽是什么-怎么使用" class="header-anchor">#</a> 插槽是什么，怎么使用</h1> <h1 id="es6常见语法"><a href="#es6常见语法" class="header-anchor">#</a> ES6常见语法</h1> <h1 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h1> <h1 id="媒体查询是什么"><a href="#媒体查询是什么" class="header-anchor">#</a> 媒体查询是什么</h1> <h1 id="首屏性能优化怎么做"><a href="#首屏性能优化怎么做" class="header-anchor">#</a> 首屏性能优化怎么做</h1> <h1 id="浏览器的性能监控怎么做"><a href="#浏览器的性能监控怎么做" class="header-anchor">#</a> 浏览器的性能监控怎么做</h1> <h1 id="怎么解决白屏问题"><a href="#怎么解决白屏问题" class="header-anchor">#</a> 怎么解决白屏问题</h1> <h1 id="diff算法是什么"><a href="#diff算法是什么" class="header-anchor">#</a> Diff算法是什么</h1> <h1 id="常见检测数据类型的方式"><a href="#常见检测数据类型的方式" class="header-anchor">#</a> 常见检测数据类型的方式</h1> <h1 id="data为什么是一个函数而不是一个对象"><a href="#data为什么是一个函数而不是一个对象" class="header-anchor">#</a> data为什么是一个函数而不是一个对象</h1> <p>js中的对象是引用类型数据，当多个实例引用同一个对象时，只要一个实例对该对象进行操作，其他实例中的数据也会跟着改变。</p> <p>在Vue中，更多的是要复用组件，因此每个组件都要有自己的数据，这样组件间才不会相互干扰。</p> <p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值形式定义，这样每次复用组件时就返回一个新的data</p> <h1 id="如何把类数组转换为数组"><a href="#如何把类数组转换为数组" class="header-anchor">#</a> 如何把类数组转换为数组</h1> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//通过call调用数组的slice方法实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>

<span class="token comment">//通过call调用数组的splice方法实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">//通过apply调用数组的concat方法实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arrayLike<span class="token punctuation">)</span>

<span class="token comment">//Array.from实现</span>
Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>
</code></pre></div><h1 id="前端登录流程"><a href="#前端登录流程" class="header-anchor">#</a> 前端登录流程</h1> <p>1.初次登录，前端调用后端的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码</p> <p>2.验证成功，返回前端一个token和一个用户信息的值</p> <p>3.前端拿到token，将token存储到<code>Vuex</code>中，然后从<code>Vuex</code>中把token值存入浏览器的<code>cookies</code>中</p> <p>4.把用户信息存到<code>Vuex</code>，然后再存储到<code>LocalStorage</code>中，然后跳转到下一个页面</p> <p>5.根据后端接口的要求，只要不登陆就不能访问的页面需要在前端每次跳转页面时判断<code>cookies</code>中是否有token，没有就跳转到登录页，有就跳转相应页面</p> <p>6.应该在每次发送请求的时候加上<code>token</code></p> <p>7.像是添加全局拦截器，将<code>token</code>值放入请求头中，后端判断请求头重是否有<code>token</code>，有就获取并验证<code>token</code>是否过期</p> <p>8.如果过期就会返回无效的<code>token</code>然后跳回登录页并清除本地用户信息</p> <h1 id="websocket"><a href="#websocket" class="header-anchor">#</a> websocket</h1> <h1 id="前端权限管理怎么实现"><a href="#前端权限管理怎么实现" class="header-anchor">#</a> 前端权限管理怎么实现</h1> <h1 id="常见git操作"><a href="#常见git操作" class="header-anchor">#</a> 常见git操作</h1></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#执行上下文类型" class="sidebar-link reco-side-执行上下文类型" data-v-cb1513f6>执行上下文类型</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#执行栈" class="sidebar-link reco-side-执行栈" data-v-cb1513f6>执行栈</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#变量提升和函数提升" class="sidebar-link reco-side-变量提升和函数提升" data-v-cb1513f6>变量提升和函数提升</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#圣杯布局-左右固定中间自适应" class="sidebar-link reco-side-圣杯布局-左右固定中间自适应" data-v-cb1513f6>圣杯布局：左右固定中间自适应</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#局部变量和全局变量的销毁" class="sidebar-link reco-side-局部变量和全局变量的销毁" data-v-cb1513f6>局部变量和全局变量的销毁</a></li><li class="level-3" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#局部变量" class="sidebar-link reco-side-局部变量" data-v-cb1513f6>局部变量</a></li><li class="level-3" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#全局变量" class="sidebar-link reco-side-全局变量" data-v-cb1513f6>全局变量</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#mvc" class="sidebar-link reco-side-mvc" data-v-cb1513f6>MVC</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#mvvm" class="sidebar-link reco-side-mvvm" data-v-cb1513f6>MVVM</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#双向数据绑定的实现原理" class="sidebar-link reco-side-双向数据绑定的实现原理" data-v-cb1513f6>双向数据绑定的实现原理</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#常用指令" class="sidebar-link reco-side-常用指令" data-v-cb1513f6>常用指令</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#修饰符" class="sidebar-link reco-side-修饰符" data-v-cb1513f6>修饰符</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#nexttick" class="sidebar-link reco-side-nexttick" data-v-cb1513f6>nextTick</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#动态class和style" class="sidebar-link reco-side-动态class和style" data-v-cb1513f6>动态class和style</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#computed和watch区别" class="sidebar-link reco-side-computed和watch区别" data-v-cb1513f6>computed和watch区别</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#h5常用新特性" class="sidebar-link reco-side-h5常用新特性" data-v-cb1513f6>h5常用新特性：</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#slice-截取功能" class="sidebar-link reco-side-slice-截取功能" data-v-cb1513f6>slice：截取功能</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#splice-数组增删查改" class="sidebar-link reco-side-splice-数组增删查改" data-v-cb1513f6>splice：数组增删查改</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#split-字符串-数组" class="sidebar-link reco-side-split-字符串-数组" data-v-cb1513f6>split：字符串=&gt;数组</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#强缓存" class="sidebar-link reco-side-强缓存" data-v-cb1513f6>强缓存</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#协商缓存" class="sidebar-link reco-side-协商缓存" data-v-cb1513f6>协商缓存</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#hash模式" class="sidebar-link reco-side-hash模式" data-v-cb1513f6>hash模式</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#history模式" class="sidebar-link reco-side-history模式" data-v-cb1513f6>history模式</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#二者选择" class="sidebar-link reco-side-二者选择" data-v-cb1513f6>二者选择</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#cookie" class="sidebar-link reco-side-cookie" data-v-cb1513f6>cookie</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#session" class="sidebar-link reco-side-session" data-v-cb1513f6>session</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#cookie和session的区别" class="sidebar-link reco-side-cookie和session的区别" data-v-cb1513f6>cookie和session的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#token" class="sidebar-link reco-side-token" data-v-cb1513f6>token</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#token和session的区别" class="sidebar-link reco-side-token和session的区别" data-v-cb1513f6>token和session的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#总结" class="sidebar-link reco-side-总结" data-v-cb1513f6>总结</a></li><li class="level-2" data-v-cb1513f6><a href="/hongsir_blog/handbook/test.html#localstorage和sessionstorage" class="sidebar-link reco-side-localstorage和sessionstorage" data-v-cb1513f6>localStorage和sessionStorage</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/hongsir_blog/assets/js/app.9297bffd.js" defer></script><script src="/hongsir_blog/assets/js/3.ebdb556f.js" defer></script><script src="/hongsir_blog/assets/js/1.52e1aeda.js" defer></script><script src="/hongsir_blog/assets/js/11.c738428c.js" defer></script>
  </body>
</html>
